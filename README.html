<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Xerus Framework Documentation</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 20px; }
        h1, h2, h3 { border-bottom: 1px solid #eaeaea; padding-bottom: 10px; }
        pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
        code { font-family: monospace; color: #333; }
        .filename { font-family: monospace; color: #666; font-size: 0.9em; margin-bottom: 5px; display: block; font-weight: bold; }
        section { margin-bottom: 40px; }
    </style>
</head>
<body>

<header>
    <h1>Xerus Framework Documentation</h1>
    <p>Comprehensive guide and examples for the Xerus HTTP & WebSocket framework.</p>
</header>

<main>

    <section id="basics">
        <h2>1. Basics</h2>
        <p>Fundamental concepts for setting up a server and defining routes.</p>

        <h3>Hello World</h3>
        <span class="filename">examples/0_hello.ts</span>
        <pre><code>import { Xerus } from "../src/Xerus";
import { HTTPContext } from "../src/HTTPContext";

const app = new Xerus();

app.get("/", async (c: HTTPContext) => {
  return c.html("&lt;h1&gt;Hello from Xerus! üêøÔ∏è&lt;/h1&gt;");
});

console.log("Listening on http://localhost:8080");
await app.listen(8080);</code></pre>

        <h3>Response Methods</h3>
        <p>Helper methods for sending Text, JSON, HTML, and Redirects.</p>
        <span class="filename">examples/1_methods.ts</span>
        <pre><code>app.get("/text", async (c) => c.text("Just some plain text."));
app.get("/json", async (c) => c.json({ framework: "Xerus", speed: "Fast" }));
app.get("/html", async (c) => c.html("&lt;h1&gt;Rich HTML&lt;/h1&gt;"));
app.get("/go-home", async (c) => c.redirect("/html"));</code></pre>

        <h3>Parameters & Query Strings</h3>
        <p>Accessing dynamic route parameters (<code>:id</code>) and URL query strings.</p>
        <span class="filename">examples/2_params_and_query.ts</span>
        <pre><code>// Dynamic Parameters: /user/123
app.get("/user/:id", async (c) => {
  const userId = c.getParam("id");
  return c.json({ userId });
});

// Query Strings: /search?q=bun&limit=10
app.get("/search", async (c) => {
  const query = c.query("q");
  const limit = c.query("limit", "10"); // Default to 10
  return c.json({ search_term: query, results_limit: limit });
});</code></pre>
    </section>

    <section id="request-handling">
        <h2>2. Request Handling & Data</h2>
        
        <h3>Body Parsing</h3>
        <p>Parsing JSON, Text, Forms, and Multipart data using the <code>BodyType</code> enum.</p>
        <span class="filename">examples/3_body_parsing.ts</span>
        <pre><code>import { BodyType } from "../src/BodyType";

// Parse JSON
app.post("/api/json", async (c) => {
  const data = await c.parseBody(BodyType.JSON);
  return c.json({ received: data });
});

// Parse File Uploads
app.post("/api/upload", async (c) => {
  const data = await c.parseBody(BodyType.MULTIPART_FORM) as FormData;
  const file = data.get("file"); 
  return c.json({ fileName: file instanceof File ? file.name : "unknown" });
});</code></pre>

        <h3>Cookie Management</h3>
        <p>Setting, reading, and clearing HTTP cookies.</p>
        <span class="filename">examples/6_cookies.ts</span>
        <pre><code>app.get("/login", async (c) => {
  c.setCookie("session_id", "xyz-123", {
    httpOnly: true,
    maxAge: 3600,
    sameSite: "Lax"
  });
  return c.text("Cookie Set!");
});

app.get("/dashboard", async (c) => {
  const session = c.getCookie("session_id");
  return c.text(`Logged in with session: ${session}`);
});</code></pre>

        <h3>File Downloads</h3>
        <p>Serving arbitrary files from disk within a handler.</p>
        <span class="filename">examples/15_file_download.ts</span>
        <pre><code>app.get("/download", async (c) => {
  await c.file("./README.md");
});</code></pre>

        <h3>Context Storage (Request Scoped Data)</h3>
        <p>Sharing data between middleware and handlers using <code>setStore/getStore</code>.</p>
        <span class="filename">examples/16_request_scoped_data.ts</span>
        <pre><code>const attachUser = new Middleware(async (c, next) => {
  c.setStore("user", { id: 1, name: "Jace" });
  await next();
});

app.get("/me", async (c) => {
  const user = c.getStore("user");
  return c.json({ user });
}, attachUser);</code></pre>
    </section>

    <section id="middleware">
        <h2>3. Middleware & Architecture</h2>

        <h3>Custom Middleware</h3>
        <p>Defining middleware with the Onion pattern (await next).</p>
        <span class="filename">examples/4_middleware.ts</span>
        <pre><code>const requireAuth = new Middleware(async (c, next) => {
  const token = c.getHeader("Authorization");
  if (token !== "secret-token") {
    return c.setStatus(401).json({ error: "Unauthorized" });
  }
  await next();
});

app.use(logger); // Global
app.get("/admin", async (c) => c.text("Admin"), requireAuth); // Local</code></pre>

        <h3>Route Grouping</h3>
        <p>Organizing routes under prefixes and applying shared middleware.</p>
        <span class="filename">examples/5_groups.ts</span>
        <pre><code>const api = app.group("/api/v1", apiKeyMiddleware);

api.get("/users", async (c) => {
  return c.json([{ id: 1, name: "Alice" }]);
});</code></pre>

        <h3>Middleware Safeguards</h3>
        <p>Xerus detects "floating promises" where middleware forgets to <code>await next()</code>.</p>
        <span class="filename">examples/11_middlware_safeguard.ts</span>
        <pre><code>// This triggers a 500 Error
const mwBroken = new Middleware(async (c, next) => {
  next(); // Missing await!
});</code></pre>

        <h3>CORS</h3>
        <p>Built-in CORS middleware configuration.</p>
        <span class="filename">examples/13_cors.ts</span>
        <pre><code>import { cors } from "../src/Middleware";

app.use(cors({
  origin: "https://example.com",
  methods: ["GET", "POST"],
  credentials: true
}));</code></pre>

        <h3>Dependency Injection</h3>
        <p>Injecting services (like Databases) into the context via middleware.</p>
        <span class="filename">examples/25_dependency_injection.ts</span>
        <pre><code>const injectDB = new Middleware(async (c, next) => {
  c.setStore("db", new Database());
  await next();
});

app.use(injectDB);</code></pre>

        <h3>Object Pooling</h3>
        <p>Optimizing high-throughput scenarios by recycling context objects.</p>
        <span class="filename">examples/17_http_context_pool.ts</span>
        <pre><code>// Recycle up to 500 context objects to reduce GC pressure
app.setHTTPContextPool(500);</code></pre>
    </section>

    <section id="validation">
        <h2>4. Validation</h2>
        <p>Class-based, type-safe validation powered by Zod.</p>

        <h3>Basic Body Validation</h3>
        <p>Validating JSON bodies and injecting the typed class instance.</p>
        <span class="filename">examples/10_validation.ts</span>
        <pre><code>class CreateUserRequest {
  static schema = z.object({ username: z.string().min(3) });
  public username: string;
  constructor(data: any) { this.username = data.username; }
  validate() { CreateUserRequest.schema.parse(this); }
}

app.post("/users", async (c) => {
  const user = c.getValid(CreateUserRequest); // Typed!
  return c.json({ name: user.username });
}, Validator(CreateUserRequest));</code></pre>

        <h3>Multiple Validators</h3>
        <p>Chaining multiple validators on a single route.</p>
        <span class="filename">examples/19_multi_validator.ts</span>
        <pre><code>app.post("/create", async (c) => {
  const user = c.getValid(User);
  const meta = c.getValid(Meta);
  c.json({ user, meta });
}, Validator(User), Validator(Meta));</code></pre>

        <h3>Flexible Sources</h3>
        <p>Validating Headers, Query Params, and Path Params using <code>Source</code>.</p>
        <span class="filename">examples/22_flexible_validation.ts</span>
        <pre><code>import { Source } from "../src/ValidationSource";

app.get("/users/:id", async (c) => {
  const { id } = c.getValid(UserIdParam);
}, Validator(UserIdParam, Source.PARAM("id")));</code></pre>
    </section>

    <section id="advanced-routing">
        <h2>5. Advanced Routing & Content</h2>

        <h3>Static Files & Embedding</h3>
        <p>Serving from disk or embedding files into the binary with Bun Macros.</p>
        <span class="filename">examples/7_static_files.ts</span>
        <pre><code>import { embedDir } from "../src/macros" with { type: "macro" };

// Disk
app.static("/files", resolve("."));

// Embedded Memory
const assets = embedDir(resolve("../src"));
app.embed("/assets", assets);</code></pre>

        <h3>Route Precedence</h3>
        <p>Understanding how Exact, Param, and Wildcard routes resolve.</p>
        <span class="filename">examples/12_conflict_routes.ts</span>
        <pre><code>// 1. Exact (/files/static) wins
// 2. Param (/files/:id) is second
// 3. Wildcard (/files/*) is last fallback</code></pre>

        <h3>Streaming</h3>
        <p>Streaming responses using <code>ReadableStream</code>.</p>
        <span class="filename">examples/14_streaming.ts</span>
        <pre><code>app.get("/stream", async (c) => {
  const stream = new ReadableStream({ ... });
  c.stream(stream);
});</code></pre>

        <h3>Server-Sent Events (SSE)</h3>
        <p>Using streams to push events to the client.</p>
        <span class="filename">examples/24_server_sent_events.ts</span>
        <pre><code>app.get("/events", async (c) => {
  c.setHeader("Content-Type", "text/event-stream");
  // ... create stream ...
  c.stream(stream);
});</code></pre>

        <h3>HTMX Integration</h3>
        <p>Checking headers to return HTML fragments.</p>
        <span class="filename">examples/26_htmx_fragments.ts</span>
        <pre><code>app.get("/search", async (c) => {
  if (c.getHeader("HX-Request")) {
    return c.html("&lt;li&gt;Fragment Only&lt;/li&gt;");
  }
  return c.html("&lt;html&gt;Full Page&lt;/html&gt;");
});</code></pre>
    </section>

    <section id="websockets">
        <h2>6. WebSockets</h2>

        <h3>Basic Handlers</h3>
        <p>Handling Open, Message, and Close events.</p>
        <span class="filename">examples/8_websocket.ts</span>
        <pre><code>app.open("/chat", async (ws) => ws.send("Welcome!"));
app.message("/chat", async (ws, msg) => ws.send(`Echo: ${msg}`));</code></pre>

        <h3>Grouped WebSockets</h3>
        <p>Using Route Groups with WebSockets.</p>
        <span class="filename">examples/20_ws_grouped_chat.ts</span>
        <pre><code>const ws = app.group("/ws");
ws.message("/chat", async (ws, msg) => { ... });</code></pre>

        <h3>WebSocket Validation</h3>
        <p>Validating incoming messages using <code>Source.WS_MESSAGE</code>.</p>
        <span class="filename">examples/23_ws_validation.ts</span>
        <pre><code>class ChatMessage { ... }

ws.message("/channel", async (ws, raw) => {
  const msg = ws.data.getValid(ChatMessage); // Fully typed
  console.log(msg.text);
}, Validator(ChatMessage, Source.WS_MESSAGE));</code></pre>
    </section>

    <section id="error-handling">
        <h2>7. Error Handling</h2>
        <p>Handling 404s, global errors, and async error propagation.</p>
        <span class="filename">examples/9_error_handling.ts</span>
        <pre><code>// 404 Handler
app.onNotFound(async (c) => {
  return c.setStatus(404).json({ error: "Not Found" });
});

// Global Error Handler
app.onErr(async (c) => {
  const err = c.getErr();
  return c.setStatus(500).json({ error: err.message });
});</code></pre>

        <span class="filename">examples/18_async_error_propagation.ts</span>
        <p>Errors thrown in handlers automatically bubble up through middleware to the global handler.</p>
    </section>

</main>
</body>
</html>