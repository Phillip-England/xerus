<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Xerus Framework</title>
</head>
<body>

<h1>Xerus üêøÔ∏è</h1>

<p>
  <strong>Xerus</strong> is a high-performance, native web framework for <strong>Bun</strong>.
  It is designed around deterministic routing, zero-allocation hot paths, and strict
  middleware correctness.
</p>

<hr />

<h2>Features</h2>
<ul>
  <li>üöÄ <strong>Bun Native:</strong> Built directly on Bun‚Äôs <code>serve</code> and <code>file</code> APIs.</li>
  <li>üßÖ <strong>Onion Middleware:</strong> Koa-style <code>await next()</code> with runtime safeguard enforcement.</li>
  <li>‚ôªÔ∏è <strong>Object Pooling:</strong> Reuses <code>HTTPContext</code> instances to reduce GC pressure.</li>
  <li>üõ°Ô∏è <strong>Class-Based Validation:</strong> Zod-backed request validation using constructors.</li>
  <li>‚ö° <strong>Trie Router:</strong> Deterministic precedence (Exact &gt; Param &gt; Wildcard).</li>
  <li>üì¶ <strong>Embedded Assets:</strong> Compile static files into a single binary via Bun macros.</li>
  <li>üîå <strong>WebSockets:</strong> Middleware-aware lifecycle hooks.</li>
</ul>

<hr />

<h2>Installation</h2>
<pre><code class="language-bash">bun add xerus</code></pre>

<hr />

<h2>1. Hello World</h2>
<p>Minimal Xerus server. (Source: <code>examples/0_hello.ts</code>)</p>

<pre><code class="language-ts">import { Xerus } from "../src/Xerus";
import { HTTPContext } from "../src/HTTPContext";

const app = new Xerus();

app.get("/", async (c: HTTPContext) => {
  return c.html("&lt;h1&gt;Hello from Xerus! üêøÔ∏è&lt;/h1&gt;");
});

await app.listen(8080);</code></pre>

<hr />

<h2>2. Response Helpers</h2>
<p>Text, JSON, HTML, and redirects. (Source: <code>examples/1_methods.ts</code>)</p>

<pre><code class="language-ts">app.get("/text", (c) => c.text("Just some plain text."));
app.get("/json", (c) => c.json({ framework: "Xerus" }));
app.get("/html", (c) => c.html("&lt;h1&gt;HTML&lt;/h1&gt;"));
app.get("/go-home", (c) => c.redirect("/html"));</code></pre>

<hr />

<h2>3. Route Params &amp; Queries</h2>
<p>Named parameters and query helpers. (Source: <code>examples/2_params_and_query.ts</code>)</p>

<pre><code class="language-ts">app.get("/user/:id", (c) => {
  return c.json({ id: c.getParam("id") });
});

app.get("/search", (c) => {
  return c.json({
    q: c.query("q"),
    limit: c.query("limit", "10"),
  });
});</code></pre>

<hr />

<h2>4. Body Parsing &amp; Caching</h2>
<p>
  Xerus caches request bodies so they can be safely read multiple times.
  (Source: <code>examples/3_body_parsing.ts</code>)
</p>

<pre><code class="language-ts">const raw = await c.parseBody(BodyType.TEXT);
const json = await c.parseBody(BodyType.JSON);</code></pre>

<hr />

<h2>5. Middleware</h2>
<p>
  Onion-style middleware with explicit execution guarantees.
  (Source: <code>examples/4_middleware.ts</code>)
</p>

<pre><code class="language-ts">const auth = new Middleware(async (c, next) => {
  if (c.getHeader("Authorization") !== "secret") {
    return c.setStatus(401).json({ error: "Unauthorized" });
  }
  await next();
});</code></pre>

<h3>Middleware Safeguards</h3>
<p>
  Xerus detects floating promises. Calling <code>next()</code> without awaiting it
  triggers a runtime error.
  (Source: <code>examples/11_middlware_safeguard.ts</code>)
</p>

<pre><code class="language-ts">// ‚ùå Incorrect
next();

// ‚úÖ Correct
await next();</code></pre>

<hr />

<h2>6. Route Groups</h2>
<p>Shared prefixes and middleware. (Source: <code>examples/5_groups.ts</code>)</p>

<pre><code class="language-ts">const api = app.group("/api/v1", apiKeyMiddleware);
api.get("/users", (c) => c.json([]));</code></pre>

<hr />

<h2>7. Cookies</h2>
<p>Secure cookie helpers. (Source: <code>examples/6_cookies.ts</code>)</p>

<pre><code class="language-ts">c.setCookie("session_id", "xyz", { httpOnly: true });
const session = c.getCookie("session_id");
c.clearCookie("session_id");</code></pre>

<hr />

<h2>8. Static Files &amp; Embedding</h2>
<p>
  Serve from disk or embed at compile time.
  (Source: <code>examples/7_static_files.ts</code>)
</p>

<pre><code class="language-ts">app.static("/files", resolve("."));
const embedded = embedDir(resolve("../src"));
app.embed("/source", embedded);</code></pre>

<hr />

<h2>9. WebSockets</h2>
<p>Lifecycle hooks with middleware support. (Source: <code>examples/8_websocket.ts</code>)</p>

<pre><code class="language-ts">app.ws("/chat", {
  open: async (ws) => ws.send("Welcome"),
  message: async (ws, msg) => ws.send(msg),
});</code></pre>

<hr />

<h2>10. Error Handling</h2>
<p>Custom 404 and global error hooks. (Source: <code>examples/9_error_handling.ts</code>)</p>

<pre><code class="language-ts">app.onNotFound((c) => c.setStatus(404).json({ error: "Not Found" }));
app.onErr((c) => c.setStatus(500).json({ error: "Internal Error" }));</code></pre>

<hr />

<h2>11. Validation (Multiple Classes)</h2>
<p>
  Multiple validators may run on the same request.
  Data is retrieved by constructor, not string keys.
  (Source: <code>examples/10_validation.ts</code>)
</p>

<pre><code class="language-ts">const user = c.getValid(CreateUserRequest);
const meta = c.getValid(MetadataRequest);</code></pre>

<hr />

<h2>12. Routing Precedence</h2>
<p>
  Deterministic routing: Exact &gt; Param &gt; Wildcard.
  (Source: <code>examples/12_conflict_routes.ts</code>)
</p>

<hr />

<h2>13. CORS</h2>
<p>Built-in CORS middleware. (Source: <code>examples/13_cors.ts</code>)</p>

<pre><code class="language-ts">app.use(cors());
app.get("/restricted", handler, cors({ origin: "https://example.com" }));</code></pre>

<hr />

<h2>14. Streaming Responses</h2>
<p>Native <code>ReadableStream</code> support. (Source: <code>examples/14_streaming.ts</code>)</p>

<hr />

<h2>15. File Downloads</h2>
<p>Send files with proper headers. (Source: <code>examples/15_file_download.ts</code>)</p>

<hr />

<h2>16. Request-Scoped Data</h2>
<p>Per-request storage via <code>HTTPContext</code>. (Source: <code>examples/16_request_scoped_data.ts</code>)</p>

<hr />

<h2>17. HTTPContext Pooling</h2>
<p>Configure pool size for high-load services. (Source: <code>examples/17_http_context_pool.ts</code>)</p>

<hr />

<h2>18. Async Error Propagation</h2>
<p>Errors bubble correctly through middleware. (Source: <code>examples/18_async_error_propagation.ts</code>)</p>

<hr />

<h2>19. Multiple Validators</h2>
<p>Multiple validation classes from one body. (Source: <code>examples/19_multi_validator.ts</code>)</p>

<hr />

<h2>20. Grouped WebSockets</h2>
<p>WebSockets inside route groups. (Source: <code>examples/20_ws_grouped_chat.ts</code>)</p>

<hr />

<h2>21. Route Introspection</h2>
<p>Demonstrates exact vs param vs wildcard resolution. (Source: <code>examples/21_route_introspection.ts</code>)</p>

<hr />

<h2>Appendix: Example Directory</h2>
<p>
  The <code>examples/</code> directory is the canonical documentation source.
  This README is generated from <code>README.html</code> using:
</p>

<pre><code class="language-bash">make readme</code></pre>

</body>
</html>
