<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Xerus Framework</title>
</head>
<body>

<h1>Xerus üêøÔ∏è</h1>

<p>
  <strong>Xerus</strong> is a high-performance, native web framework for <strong>Bun</strong>.
  It is designed around deterministic routing, zero-allocation hot paths, and strict
  middleware correctness.
</p>

<hr />

<h2>Features</h2>
<ul>
  <li>üöÄ <strong>Bun Native:</strong> Built directly on Bun‚Äôs <code>serve</code> and <code>file</code> APIs.</li>
  <li>üßÖ <strong>Onion Middleware:</strong> Koa-style <code>await next()</code> with runtime safeguard enforcement.</li>
  <li>‚ôªÔ∏è <strong>Object Pooling:</strong> Reuses <code>HTTPContext</code> instances to reduce GC pressure.</li>
  <li>üõ°Ô∏è <strong>Class-Based Validation:</strong> Zod-backed request validation using constructors and DI.</li>
  <li>‚ö° <strong>Trie Router:</strong> Deterministic precedence (Exact &gt; Param &gt; Wildcard).</li>
  <li>üì¶ <strong>Embedded Assets:</strong> Compile static files into a single binary via Bun macros.</li>
  <li>üîå <strong>WebSockets:</strong> Middleware-aware lifecycle hooks.</li>
</ul>

<hr />

<h2>Installation</h2>
<pre><code class="language-bash">bun add xerus</code></pre>

<hr />

<h2>1. Hello World</h2>
<p>Minimal Xerus server. (Source: <code>examples/0_hello.ts</code>)</p>

<pre><code class="language-ts">import { Xerus } from "../src/Xerus";
import { HTTPContext } from "../src/HTTPContext";

const app = new Xerus();

app.get("/", async (c: HTTPContext) => {
  return c.html("&lt;h1&gt;Hello from Xerus! üêøÔ∏è&lt;/h1&gt;");
});

console.log("Listening on http://localhost:8080");
await app.listen(8080);</code></pre>

<hr />

<h2>2. Response Helpers</h2>
<p>Text, JSON, HTML, and redirects. (Source: <code>examples/1_methods.ts</code>)</p>

<pre><code class="language-ts">app.get("/text", async (c) => c.text("Just some plain text."));
app.get("/json", async (c) => c.json({ framework: "Xerus", speed: "Fast" }));
app.get("/html", async (c) => c.html(`
  &lt;div style="font-family: sans-serif;"&gt;
    &lt;h1&gt;Rich HTML&lt;/h1&gt;
    &lt;button&gt;Click Me&lt;/button&gt;
  &lt;/div&gt;
`));
app.get("/go-home", async (c) => c.redirect("/html"));</code></pre>

<hr />

<h2>3. Route Params &amp; Queries</h2>
<p>Named parameters and query helpers. (Source: <code>examples/2_params_and_query.ts</code>)</p>

<pre><code class="language-ts">// Dynamic Parameters
app.get("/user/:id", async (c) => {
  const userId = c.getParam("id");
  return c.json({ userId });
});

// Multiple Parameters
app.get("/post/:year/:month", async (c) => {
  const { year, month } = c.params;
  return c.json({ year, month });
});

// Query Strings
app.get("/search", async (c) => {
  return c.json({ 
    search_term: c.query("q"), 
    results_limit: c.query("limit", "10") 
  });
});</code></pre>

<hr />

<h2>4. Body Parsing &amp; Caching</h2>
<p>
  Xerus caches request bodies. You can read the body as text (for logging) and then again as JSON without error.
  (Source: <code>examples/3_body_parsing.ts</code>)
</p>

<pre><code class="language-ts">app.post("/api/log-then-parse", async (c) => {
  // 1. Read as text (reuses cache if read previously)
  const rawString = await c.parseBody(BodyType.TEXT);
  console.log("Raw Body:", rawString);

  // 2. Read as JSON (reuses the cache and parses it)
  const jsonData = await c.parseBody(BodyType.JSON);
  
  return c.json({ was_logged: true, data: jsonData });
});</code></pre>

<hr />

<h2>5. Middleware</h2>
<p>
  Onion-style middleware with explicit execution guarantees.
  (Source: <code>examples/4_middleware.ts</code>)
</p>

<pre><code class="language-ts">const requireAuth = new Middleware(async (c, next) => {
  if (c.getHeader("Authorization") !== "secret-token") {
    return c.setStatus(401).json({ error: "Unauthorized" });
  }
  console.log("Auth passed!");
  await next();
});

// Use globally or per-route
app.use(logger);
app.get("/admin", async (c) => c.text("Welcome, Admin."), requireAuth);</code></pre>

<h3>Middleware Safeguards</h3>
<p>
  Xerus detects floating promises. Calling <code>next()</code> without awaiting it
  triggers a runtime error. (Source: <code>examples/11_middlware_safeguard.ts</code>)
</p>

<pre><code class="language-ts">// ‚ùå Incorrect (Triggers 500 Logic Error)
next();

// ‚úÖ Correct
await next();</code></pre>

<hr />

<h2>6. Route Groups</h2>
<p>Shared prefixes and middleware. (Source: <code>examples/5_groups.ts</code>)</p>

<pre><code class="language-ts">const api = app.group("/api/v1", apiKeyMiddleware);

// Path: /api/v1/users
api.get("/users", async (c) => {
  return c.json([{ id: 1, name: "Alice" }]);
});</code></pre>

<hr />

<h2>7. Cookies</h2>
<p>Secure cookie helpers. (Source: <code>examples/6_cookies.ts</code>)</p>

<pre><code class="language-ts">c.setCookie("session_id", "xyz-123", {
  httpOnly: true,
  maxAge: 3600,
  sameSite: "Lax"
});

const session = c.getCookie("session_id");
c.clearCookie("session_id");</code></pre>

<hr />

<h2>8. Static Files &amp; Embedding</h2>
<p>
  Serve from disk or embed at compile time.
  (Source: <code>examples/7_static_files.ts</code>)
</p>

<pre><code class="language-ts">import { embedDir } from "../src/macros" with { type: "macro" };

// 1. Disk Serving
app.static("/files", resolve(".")); 

// 2. Embedded Serving (Single Binary)
const srcFiles = embedDir(resolve("../src"));
app.embed("/source-code", srcFiles);</code></pre>

<hr />

<h2>9. WebSockets</h2>
<p>Lifecycle hooks with middleware support. (Source: <code>examples/8_websocket.ts</code>)</p>

<pre><code class="language-ts">app.ws("/chat", {
  open: {
    handler: async (ws) => {
      ws.send("Welcome to Xerus Chat!");
    },
    middlewares: [logger] // Middleware specifically for the Open event
  },
  message: async (ws, message) => {
    ws.send(`You said: ${message}`);
  }
});</code></pre>

<hr />

<h2>10. Error Handling</h2>
<p>Custom 404 and global error hooks. (Source: <code>examples/9_error_handling.ts</code>)</p>

<pre><code class="language-ts">app.onNotFound(async (c) => c.setStatus(404).json({ error: "Resource Not Found" }));

app.onErr(async (c) => {
  const err = c.getErr();
  console.error("Critical Failure:", err);
  return c.setStatus(500).json({ error: "Internal Server Error" });
});</code></pre>

<hr />

<h2>11. Class-Based Validation</h2>
<p>
  Zod-backed validation classes. Data is injected directly into the context type-safely.
  (Source: <code>examples/10_validation.ts</code>)
</p>

<pre><code class="language-ts">class CreateUserRequest {
  static schema = z.object({
    username: z.string().min(3),
    email: z.string().email()
  });
  
  constructor(data: any) {
    this.username = data.username;
    this.email = data.email;
  }

  validate() { CreateUserRequest.schema.parse(this); }
}

app.post("/users", async (c) => {
  // Retrieve validated instance
  const user = c.getValid(CreateUserRequest);
  return c.json({ name: user.username });
}, Validator(CreateUserRequest));</code></pre>

<hr />

<h2>12. Routing Precedence</h2>
<p>
  Deterministic routing: Exact &gt; Param &gt; Wildcard.
  (Source: <code>examples/12_conflict_routes.ts</code>)
</p>

<pre><code class="language-ts">// 1. Exact
app.get("/files/static", ...); 

// 2. Param (matches /files/123)
app.get("/files/:id", ...);

// 3. Wildcard (matches /files/a/b)
app.get("/files/*", ...);</code></pre>

<hr />

<h2>13. CORS</h2>
<p>Built-in CORS middleware. (Source: <code>examples/13_cors.ts</code>)</p>

<pre><code class="language-ts">// Global
app.use(cors());

// Per-Route
app.get("/restricted", handler, cors({ 
  origin: "https://example.com",
  credentials: true 
}));</code></pre>

<hr />

<h2>14. Streaming Responses</h2>
<p>Native <code>ReadableStream</code> support. (Source: <code>examples/14_streaming.ts</code>)</p>

<pre><code class="language-ts">app.get("/stream", async (c) => {
  const stream = new ReadableStream({ ... });
  c.stream(stream);
});</code></pre>

<hr />

<h2>15. File Downloads</h2>
<p>Send files with automatic MIME detection. (Source: <code>examples/15_file_download.ts</code>)</p>

<pre><code class="language-ts">app.get("/download", async (c) => {
  await c.file("./README.md");
});</code></pre>

<hr />

<h2>16. Request-Scoped Data</h2>
<p>
  Demonstrates passing data through the request lifecycle.
  (Source: <code>examples/16_request_scoped_data.ts</code>)
</p>

<hr />

<h2>17. HTTPContext Pooling</h2>
<p>Configure pool size for high-load services to reduce garbage collection. (Source: <code>examples/17_http_context_pool.ts</code>)</p>

<pre><code class="language-ts">app.setHTTPContextPool(500);</code></pre>

<hr />

<h2>18. Async Error Propagation</h2>
<p>Errors bubble correctly through async middleware chains. (Source: <code>examples/18_async_error_propagation.ts</code>)</p>

<hr />

<h2>19. Multiple Validators</h2>
<p>Apply multiple validation classes to a single route. (Source: <code>examples/19_multi_validator.ts</code>)</p>

<pre><code class="language-ts">app.post("/create", async (c) => {
    const user = c.getValid(User);
    const meta = c.getValid(Meta);
    c.json({ user, meta });
  },
  Validator(User),
  Validator(Meta)
);</code></pre>

<hr />

<h2>20. Grouped WebSockets</h2>
<p>Defining WebSocket routes inside prefix groups. (Source: <code>examples/20_ws_grouped_chat.ts</code>)</p>

<pre><code class="language-ts">const ws = app.group("/ws", logger);
ws.ws("/chat", { ... });</code></pre>

<hr />

<h2>21. Route Introspection</h2>
<p>Demonstrates how the router resolves conflicting paths. (Source: <code>examples/21_route_introspection.ts</code>)</p>

<hr />

<h2>Appendix: Example Directory</h2>
<p>
  The <code>examples/</code> directory is the canonical documentation source.
  This README is generated from <code>README.html</code> using:
</p>

<pre><code class="language-bash">make readme</code></pre>

</body>
</html>