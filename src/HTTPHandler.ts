import type { HTTPHandlerFunc, HTTPErrorHandlerFunc } from "./HTTPHandlerFunc";
import { Middleware } from "./Middleware";
import { HTTPContext } from "./HTTPContext";
import { SystemErr } from "./SystemErr";
import { SystemErrCode } from "./SystemErrCode";

export class HTTPHandler {
  private mainHandler: HTTPHandlerFunc;
  private errorHandler?: HTTPErrorHandlerFunc; // Granular Error Handler
  private middlewares: Middleware[];
  private compiledChain: (c: HTTPContext) => Promise<void>;

  constructor(mainHandler: HTTPHandlerFunc, errorHandler?: HTTPErrorHandlerFunc) {
    this.mainHandler = mainHandler;
    this.errorHandler = errorHandler;
    this.middlewares = [];
    this.compiledChain = async (c: HTTPContext) => { await this.mainHandler(c); };
  }

  setMiddlewares(middlewares: Middleware[]) {
    this.middlewares = middlewares;
    this.precompileChain();
  }

  private precompileChain() {
    // The innermost link: the actual route handler
    let chain = async (context: HTTPContext): Promise<void> => {
      await this.mainHandler(context);
    };

    // Wrap middlewares in reverse order (Onion architecture)
    for (let i = this.middlewares.length - 1; i >= 0; i--) {
      const middleware = this.middlewares[i];
      const nextChain = chain;

      chain = async (context: HTTPContext): Promise<void> => {
        let nextPending = false;

        // We wrap the next function to track its state
        const safeNext = async () => {
          nextPending = true;
          try {
            await nextChain(context);
          } finally {
            nextPending = false;
          }
        };
        
        // Execute the middleware
        await middleware.execute(context, safeNext);

        // SAFEGUARD: 
        // If nextPending is still true here, it means the middleware function 
        // returned (finished) BUT the next() promise is still running.
        // This implies they called next() but did not await it.
        if (nextPending) {
            throw new SystemErr(
              SystemErrCode.MIDDLEWARE_ERROR, 
              "A Middleware called next() but did not await it. This breaks the request lifecycle and error handling."
            );
        }
      };
    }
    this.compiledChain = chain;
  }

  async execute(c: HTTPContext): Promise<Response> {
    try {
      await this.compiledChain(c);
    } catch (e: any) {
      // 1. Check for Granular Error Handler
      if (this.errorHandler) {
        c.setErr(e);
        try {
          await this.errorHandler(c, e);
        } catch (handlerErr: any) {
          // If the error handler ITSELF fails, we must bubble up
          throw handlerErr;
        }
        // If the error handler handled it successfully (didn't throw),
        // we return the response generated by the error handler.
        return c.res.send();
      }

      // 2. No Granular Handler? Bubble up to Xerus.handleHTTP (Global Handler)
      throw e;
    }
    
    return c.res.send();
  }
}